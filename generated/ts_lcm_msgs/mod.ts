// Auto-generated by lcm-ts. DO NOT EDIT.

import * as actionlib_msgs from "./actionlib_msgs/mod.ts";
import * as builtin_interfaces from "./builtin_interfaces/mod.ts";
import * as diagnostic_msgs from "./diagnostic_msgs/mod.ts";
import * as foxglove_msgs from "./foxglove_msgs/mod.ts";
import * as geometry_msgs from "./geometry_msgs/mod.ts";
import * as nav_msgs from "./nav_msgs/mod.ts";
import * as sensor_msgs from "./sensor_msgs/mod.ts";
import * as shape_msgs from "./shape_msgs/mod.ts";
import * as std_msgs from "./std_msgs/mod.ts";
import * as stereo_msgs from "./stereo_msgs/mod.ts";
import * as tf2_msgs from "./tf2_msgs/mod.ts";
import * as trajectory_msgs from "./trajectory_msgs/mod.ts";
import * as vision_msgs from "./vision_msgs/mod.ts";
import * as visualization_msgs from "./visualization_msgs/mod.ts";

// Re-export all packages
export * as actionlib_msgs from "./actionlib_msgs/mod.ts";
export * as builtin_interfaces from "./builtin_interfaces/mod.ts";
export * as diagnostic_msgs from "./diagnostic_msgs/mod.ts";
export * as foxglove_msgs from "./foxglove_msgs/mod.ts";
export * as geometry_msgs from "./geometry_msgs/mod.ts";
export * as nav_msgs from "./nav_msgs/mod.ts";
export * as sensor_msgs from "./sensor_msgs/mod.ts";
export * as shape_msgs from "./shape_msgs/mod.ts";
export * as std_msgs from "./std_msgs/mod.ts";
export * as stereo_msgs from "./stereo_msgs/mod.ts";
export * as tf2_msgs from "./tf2_msgs/mod.ts";
export * as trajectory_msgs from "./trajectory_msgs/mod.ts";
export * as vision_msgs from "./vision_msgs/mod.ts";
export * as visualization_msgs from "./visualization_msgs/mod.ts";

// Message registry for decoding by type name
interface MessageClass<T> {
  readonly _NAME: string;
  readonly _HASH: bigint;
  decode(data: Uint8Array): T;
}

const _types = new Map<string, MessageClass<unknown>>();

function _registerPackage(pkg: Record<string, unknown>): void {
  for (const value of Object.values(pkg)) {
    if (value && typeof value === "function" && "_NAME" in value && "_HASH" in value && "decode" in value) {
      _types.set((value as MessageClass<unknown>)._NAME, value as MessageClass<unknown>);
    }
  }
}

const _registry = { registerPackage: _registerPackage };
  _registry.registerPackage(actionlib_msgs);
  _registry.registerPackage(builtin_interfaces);
  _registry.registerPackage(diagnostic_msgs);
  _registry.registerPackage(foxglove_msgs);
  _registry.registerPackage(geometry_msgs);
  _registry.registerPackage(nav_msgs);
  _registry.registerPackage(sensor_msgs);
  _registry.registerPackage(shape_msgs);
  _registry.registerPackage(std_msgs);
  _registry.registerPackage(stereo_msgs);
  _registry.registerPackage(tf2_msgs);
  _registry.registerPackage(trajectory_msgs);
  _registry.registerPackage(vision_msgs);
  _registry.registerPackage(visualization_msgs);

/**
 * Decode an LCM message from binary data.
 * @param typeOrName - Message class or type name string (e.g., "geometry_msgs.PoseStamped")
 * @param data - Binary data including LCM hash prefix
 */
export function decode<T>(typeOrName: MessageClass<T> | string, data: Uint8Array): T {
  if (typeof typeOrName === "string") {
    const cls = _types.get(typeOrName);
    if (!cls) throw new Error(`Unknown message type: ${typeOrName}`);
    return cls.decode(data) as T;
  }
  return typeOrName.decode(data);
}

/**
 * Try to decode, returning null on failure.
 */
export function tryDecode<T>(typeOrName: MessageClass<T> | string, data: Uint8Array): T | null {
  try {
    return decode(typeOrName, data);
  } catch {
    return null;
  }
}

/** Get all registered type names */
export function getTypeNames(): string[] {
  return [..._types.keys()];
}

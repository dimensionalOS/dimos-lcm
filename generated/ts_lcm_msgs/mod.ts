// Auto-generated by lcm-ts. DO NOT EDIT.

import * as actionlib_msgs from "./actionlib_msgs/mod.ts";
import * as builtin_interfaces from "./builtin_interfaces/mod.ts";
import * as diagnostic_msgs from "./diagnostic_msgs/mod.ts";
import * as foxglove_msgs from "./foxglove_msgs/mod.ts";
import * as geometry_msgs from "./geometry_msgs/mod.ts";
import * as nav_msgs from "./nav_msgs/mod.ts";
import * as sensor_msgs from "./sensor_msgs/mod.ts";
import * as shape_msgs from "./shape_msgs/mod.ts";
import * as std_msgs from "./std_msgs/mod.ts";
import * as stereo_msgs from "./stereo_msgs/mod.ts";
import * as tf2_msgs from "./tf2_msgs/mod.ts";
import * as trajectory_msgs from "./trajectory_msgs/mod.ts";
import * as vision_msgs from "./vision_msgs/mod.ts";
import * as visualization_msgs from "./visualization_msgs/mod.ts";

// Re-export all packages
export * as actionlib_msgs from "./actionlib_msgs/mod.ts";
export * as builtin_interfaces from "./builtin_interfaces/mod.ts";
export * as diagnostic_msgs from "./diagnostic_msgs/mod.ts";
export * as foxglove_msgs from "./foxglove_msgs/mod.ts";
export * as geometry_msgs from "./geometry_msgs/mod.ts";
export * as nav_msgs from "./nav_msgs/mod.ts";
export * as sensor_msgs from "./sensor_msgs/mod.ts";
export * as shape_msgs from "./shape_msgs/mod.ts";
export * as std_msgs from "./std_msgs/mod.ts";
export * as stereo_msgs from "./stereo_msgs/mod.ts";
export * as tf2_msgs from "./tf2_msgs/mod.ts";
export * as trajectory_msgs from "./trajectory_msgs/mod.ts";
export * as vision_msgs from "./vision_msgs/mod.ts";
export * as visualization_msgs from "./visualization_msgs/mod.ts";

// Message registry for decoding by hash
interface MessageClass<T> {
  readonly _NAME: string;
  readonly _HASH: bigint;
  decode(data: Uint8Array): T;
}

const _byHash = new Map<bigint, MessageClass<unknown>>();
const _byName = new Map<string, MessageClass<unknown>>();

function _registerPackage(pkg: Record<string, unknown>): void {
  for (const value of Object.values(pkg)) {
    if (value && typeof value === "function" && "_NAME" in value && "_HASH" in value && "decode" in value) {
      const cls = value as MessageClass<unknown>;
      _byHash.set(cls._HASH, cls);
      _byName.set(cls._NAME, cls);
    }
  }
}

const _registry = { registerPackage: _registerPackage };
  _registry.registerPackage(actionlib_msgs);
  _registry.registerPackage(builtin_interfaces);
  _registry.registerPackage(diagnostic_msgs);
  _registry.registerPackage(foxglove_msgs);
  _registry.registerPackage(geometry_msgs);
  _registry.registerPackage(nav_msgs);
  _registry.registerPackage(sensor_msgs);
  _registry.registerPackage(shape_msgs);
  _registry.registerPackage(std_msgs);
  _registry.registerPackage(stereo_msgs);
  _registry.registerPackage(tf2_msgs);
  _registry.registerPackage(trajectory_msgs);
  _registry.registerPackage(vision_msgs);
  _registry.registerPackage(visualization_msgs);

function _readHash(data: Uint8Array): bigint {
  const view = new DataView(data.buffer, data.byteOffset, 8);
  return view.getBigInt64(0, false); // big-endian
}

/**
 * Decode an LCM message from binary data.
 * Type is auto-detected from the hash in the first 8 bytes.
 * @param data - Binary LCM message data
 */
export function decode(data: Uint8Array): unknown {
  const hash = _readHash(data);
  const cls = _byHash.get(hash);
  if (!cls) throw new Error(`Unknown message hash: ${hash}`);
  return cls.decode(data);
}

/** Get all registered type names */
export function getTypeNames(): string[] {
  return [..._byName.keys()];
}

// LCM packet encoding/decoding for raw packet handling
const _MAGIC_SHORT = 0x4c433032; // "LC02"
const _SHORT_HEADER_SIZE = 8;

function _decodePacketHeader(packet: Uint8Array): { channel: string; payload: Uint8Array } | null {
  if (packet.length < _SHORT_HEADER_SIZE) return null;
  const view = new DataView(packet.buffer, packet.byteOffset, packet.byteLength);
  const magic = view.getUint32(0, false);
  if (magic !== _MAGIC_SHORT) return null; // Only small messages supported

  let channelEnd = _SHORT_HEADER_SIZE;
  while (channelEnd < packet.length && packet[channelEnd] !== 0) channelEnd++;
  if (channelEnd >= packet.length) return null;

  const channel = new TextDecoder().decode(packet.subarray(_SHORT_HEADER_SIZE, channelEnd));
  const payload = packet.subarray(channelEnd + 1);
  return { channel, payload };
}

/**
 * Decode a raw LCM packet into channel and typed message.
 * @param packet - Raw LCM UDP packet bytes
 * @returns Object with channel string and decoded message data
 */
export function decodePacket(packet: Uint8Array): { channel: string; data: unknown } {
  const header = _decodePacketHeader(packet);
  if (!header) throw new Error("Invalid LCM packet");
  return { channel: header.channel, data: decode(header.payload) };
}

let _seqNum = Math.floor(Math.random() * 0xFFFFFFFF);

/**
 * Encode a message into a raw LCM packet.
 * @param channel - Channel name to publish on
 * @param msg - Message instance with encode() method
 * @returns Raw LCM packet bytes ready to send
 */
export function encodePacket(channel: string, msg: { encode(): Uint8Array }): Uint8Array {
  const payload = msg.encode();
  const channelBytes = new TextEncoder().encode(channel);
  const packet = new Uint8Array(_SHORT_HEADER_SIZE + channelBytes.length + 1 + payload.length);
  const view = new DataView(packet.buffer);

  view.setUint32(0, _MAGIC_SHORT, false);
  view.setUint32(4, _seqNum++, false);
  packet.set(channelBytes, _SHORT_HEADER_SIZE);
  packet[_SHORT_HEADER_SIZE + channelBytes.length] = 0;
  packet.set(payload, _SHORT_HEADER_SIZE + channelBytes.length + 1);

  return packet;
}

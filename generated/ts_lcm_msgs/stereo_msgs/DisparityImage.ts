// Auto-generated by lcm-ts. DO NOT EDIT.

import { Header } from "../std_msgs/Header.ts";
import { Image } from "../sensor_msgs/Image.ts";
import { RegionOfInterest } from "../sensor_msgs/RegionOfInterest.ts";

export class DisparityImage {
  static readonly _HASH = 0xe8c8cad8e8c2bec8n;
  static readonly _NAME = "stereo_msgs.DisparityImage";

  header: Header;
  image: Image;
  f: number;
  T: number;
  valid_window: RegionOfInterest;
  min_disparity: number;
  max_disparity: number;
  delta_d: number;

  constructor(init?: Partial<DisparityImage>) {
    this.header = init?.header ?? new Header();
    this.image = init?.image ?? new Image();
    this.f = init?.f ?? 0;
    this.T = init?.T ?? 0;
    this.valid_window = init?.valid_window ?? new RegionOfInterest();
    this.min_disparity = init?.min_disparity ?? 0;
    this.max_disparity = init?.max_disparity ?? 0;
    this.delta_d = init?.delta_d ?? 0;
  }

  static decode(data: Uint8Array): DisparityImage {
    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    let offset = 0;

    // Verify fingerprint
    const hash = view.getBigUint64(offset, false);
    offset += 8;
    if (hash !== DisparityImage._HASH) {
      throw new Error(`Hash mismatch: expected ${DisparityImage._HASH.toString(16)}, got ${hash.toString(16)}`);
    }

    const result = new DisparityImage();
    ({ offset } = DisparityImage._decodeOne(view, offset, result));
    return result;
  }

  static _decodeOne(view: DataView, offset: number, target: DisparityImage): { offset: number } {
    target.header = new Header();
    ({ offset } = Header._decodeOne(view, offset, target.header));
    target.image = new Image();
    ({ offset } = Image._decodeOne(view, offset, target.image));
    target.f = view.getFloat32(offset, false);
    offset += 4;
    target.T = view.getFloat32(offset, false);
    offset += 4;
    target.valid_window = new RegionOfInterest();
    ({ offset } = RegionOfInterest._decodeOne(view, offset, target.valid_window));
    target.min_disparity = view.getFloat32(offset, false);
    offset += 4;
    target.max_disparity = view.getFloat32(offset, false);
    offset += 4;
    target.delta_d = view.getFloat32(offset, false);
    offset += 4;
    return { offset };
  }

  encode(): Uint8Array {
    const size = 8 + this._encodedSize();
    const data = new Uint8Array(size);
    const view = new DataView(data.buffer);
    let offset = 0;

    // Write fingerprint
    view.setBigUint64(offset, DisparityImage._HASH, false);
    offset += 8;

    offset = this._encodeOne(view, offset);
    return data;
  }

  _encodeOne(view: DataView, offset: number): number {
    offset = this.header._encodeOne(view, offset);
    offset = this.image._encodeOne(view, offset);
    view.setFloat32(offset, this.f, false);
    offset += 4;
    view.setFloat32(offset, this.T, false);
    offset += 4;
    offset = this.valid_window._encodeOne(view, offset);
    view.setFloat32(offset, this.min_disparity, false);
    offset += 4;
    view.setFloat32(offset, this.max_disparity, false);
    offset += 4;
    view.setFloat32(offset, this.delta_d, false);
    offset += 4;
    return offset;
  }

  _encodedSize(): number {
    let size = 0;
    size += this.header._encodedSize();
    size += this.image._encodedSize();
    size += 4;
    size += 4;
    size += this.valid_window._encodedSize();
    size += 4;
    size += 4;
    size += 4;
    return size;
  }
}

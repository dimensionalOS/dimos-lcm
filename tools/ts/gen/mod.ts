#!/usr/bin/env -S deno run --allow-read --allow-write

// LCM TypeScript Code Generator
// Usage: deno run --allow-read --allow-write mod.ts [options] <input.lcm...>

import { parseArgs } from "jsr:@std/cli/parse-args";
import { parseFile } from "./parser.ts";
import { generate, generateToFile } from "./generator.ts";
import type { LcmFile } from "./types.ts";

const args = parseArgs(Deno.args, {
  string: ["output", "o"],
  boolean: ["help", "h", "stdout", "quiet", "q"],
  alias: {
    o: "output",
    h: "help",
    q: "quiet",
  },
  default: {
    output: ".",
  },
});

function printHelp(): void {
  console.log(`lcm-ts - LCM TypeScript Code Generator

Usage:
  lcm-ts [options] <input.lcm...>

Options:
  -o, --output <dir>   Output directory (default: .)
  --stdout             Print to stdout instead of files
  -q, --quiet          Suppress per-file output messages
  -h, --help           Show this help

Examples:
  lcm-ts -o ./generated types/*.lcm
  lcm-ts --stdout example.lcm
`);
}

if (args.help || args._.length === 0) {
  printHelp();
  Deno.exit(args.help ? 0 : 1);
}

// Parse all input files
const files: LcmFile[] = [];
for (const input of args._) {
  const path = String(input);
  try {
    const file = parseFile(path);
    files.push(file);
  } catch (e) {
    console.error(`Error parsing ${path}: ${e}`);
    Deno.exit(1);
  }
}

// Generate output
if (args.stdout) {
  for (const file of files) {
    console.log(generate(file));
  }
} else {
  // Track packages for mod.ts generation
  const packages = new Map<string, string[]>(); // package -> type names

  for (const file of files) {
    generateToFile(file, args.output, args.quiet);

    // Track types per package
    for (const type of file.types) {
      const pkg = file.package || "_default";
      if (!packages.has(pkg)) {
        packages.set(pkg, []);
      }
      packages.get(pkg)!.push(type.name);
    }
  }

  // Generate mod.ts for each package
  for (const [pkg, types] of packages) {
    const pkgPath = pkg.replace(/\./g, "/");
    const pkgDir = `${args.output}/${pkgPath}`;
    const modPath = `${pkgDir}/mod.ts`;

    const exports = types
      .sort()
      .map((t) => `export * from "./${t}.ts";`)
      .join("\n");

    const content = `// Auto-generated by lcm-ts. DO NOT EDIT.\n\n${exports}\n`;
    Deno.writeTextFileSync(modPath, content);

    if (!args.quiet) {
      console.log(`Generated: ${modPath}`);
    }
  }

  // Generate root deno.json
  const packageExports: Record<string, string> = { ".": "./mod.ts" };
  const rootExports: string[] = [];

  for (const pkg of [...packages.keys()].sort()) {
    const pkgPath = pkg.replace(/\./g, "/");
    packageExports[`./${pkgPath}`] = `./${pkgPath}/mod.ts`;
    rootExports.push(`export * as ${pkg.replace(/\./g, "_")} from "./${pkgPath}/mod.ts";`);
  }

  const denoJson = {
    name: "@dimos/msgs",
    version: "0.1.0",
    exports: packageExports,
    compilerOptions: { strict: true },
  };

  Deno.writeTextFileSync(
    `${args.output}/deno.json`,
    JSON.stringify(denoJson, null, 2) + "\n"
  );

  // Generate root mod.ts
  const rootMod = `// Auto-generated by lcm-ts. DO NOT EDIT.\n\n${rootExports.join("\n")}\n`;
  Deno.writeTextFileSync(`${args.output}/mod.ts`, rootMod);

  if (!args.quiet) {
    console.log(`Generated: ${args.output}/deno.json`);
    console.log(`Generated: ${args.output}/mod.ts`);
  }
}
